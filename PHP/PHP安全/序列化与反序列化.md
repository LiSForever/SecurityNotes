### 序列化与反序列化

#### 常见magic方法

| 方法名         | 触发点                                                       |
| -------------- | ------------------------------------------------------------ |
| __construct    | 在创建对象时候初始化对象，一般用于对变量赋初值               |
| __destruct     | 和构造函数相反，在对象不再被使用时(将所有该对象的引用设为null)或者程序退出时自动调用 |
| __toString     | 当一个对象被当作一个字符串被调用，把类当作字符串使用时触发,返回值需要为字符串 |
| __wakeup()     | 使用unserialize时触发，**反序列化恢复对象之前调用该方法。顺序在对象获取序列化字符串之后，也就是说在其中对类的属性赋值会覆盖序列化字符串的值** |
| __sleep()      | 使用serialize时触发 ，在对象被序列化前自动调用，该函数需要返回以类成员变量名作为元素的数组(该数组里的元素会影响类成员变量是否被序列化。只有出现在该数组元素里的类成员变量才会被序列化) |
| debuginfo      | 当调用var_dump()打印对象时被调用，适用于PHP5.6               |
| __call()       | 在对象上下文中调用不可访问的方法时触发，即当调用对象中不存在的方法会自动调用该方法 |
| __callStatic() | 在静态上下文中调用不可访问的方法时触发                       |
| __set_state    | 当调用var_export()导出类时，此静态方法被调用。用__set_state的返回值作为var_export的返回值 |
| __get()        | 用于从不可访问的属性读取数据，即在调用私有属性的时候会自动执行 |
| __set()        | 用于将数据写入不可访问的属性                                 |
| __isset()      | 在不可访问的属性上调用isset()或empty()触发                   |
| __unset()      | 在不可访问的属性上使用unset()时触发                          |
| __invoke()     | 当脚本尝试将对象调用为函数时触发                             |

* 常见起点
* 常见跳板
* 常见终点

##### 绕过魔术方法

* __wakeup()：当序列化字符串中的属性个数值大于这个类的实际属性个数时跳过该方法

```php
<?php
class Test{

    public $a = "a";

    public function __construct()
    {
        echo "construct<br>";
    }

    public function __wakeup(){
        echo "wakeup<br>";
    }

    public function __destruct()
    {
        echo "destruct<br>";
    }
}
$a = new Test();
var_dump($a);
echo "<br>";
echo serialize($a);
echo "<br>";
# O:4:"Test":2:{s:1:"a";s:4:"test";}会跳过该方法，O:4:"Test":1:{s:1:"a";s:4:"test";}正常执行
$s=$_GET['t'];
$b=unserialize($s);
var_dump($b);
?>
```

#### 对象序列化和反序列化

```php
	<?php
	class animal {
		public $name = 'dahuang';//define a virable
		public $age = '20';
		public function eat(){//define a simpe method
			echo $this->name . " is eatting...\n";
		}
		public function __construct(){
			echo "the method:__construct is called\n";
		}
		public function __destruct(){
			echo "the method:__destruct is called\n";
		}
		public function __toString(){
			return "the method:__toString is called\n";
		}
		public function __wakeup(){
			echo "the method:__wakeup is called\n";
		}
		public function __sleep(){
			echo "the method:__sleep is called\n";
			return array('name','age');
		}
	}
	$dog = new animal();//对类进行实例化时，自动调用__construct()
	echo serialize($dog)."\n";
	$serializedDog = serialize($dog);//对dog对象进行序列化时，自动调用__sleep()
	echo $serializedDog . "\n";//echo 序列化的dog对象
	$dog->eat();//dog对象调用eat()方法
				//程序结束，调用__destruct()
	?>

```

![在这里插入图片描述](.\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk1MDc4MQ==,size_16,color_FFFFFF,t_70)

PHP的几个魔法函数，在进行序列化的过程中的调用：

1、当不进行序列化时: 在进行类的实例化时，自动调用__construct();在输出对象时，自动调用

\_\_toString()；在程序结束时，自动调用\_\_destruct();\_\_sleep()与\_\_wakeup()均与序列化与反序列化

有关，在此过程不被调用。

2、当进行序列化时: 在进行类的实例化时，自动调用\_\_construct();在对创建的dog对象进行序列化

时，自动调用\_\_sleep()；echo $serializedDog，输出序列化的dog对象，在此不再调用

\_toString()；dog兑现调用eat()方法，然后程序结束，调用\_\_destruct().

3、在整个过程中，\_\_construct()总是在程序的开始调用，\_\_destruct()总是在程序的结束调用，这很

简单，因为，对所有的变量的初始化总是在程序的开始，释放变量总是在程序结束。

```php
	<?php
	class animal {
		public $name = 'dahuang';//define a virable
		public $age = '20';
		public function eat(){//define a simpe method
			echo $this->name . " is eatting...\n";
		}
		public function __construct(){
			echo "the method:__construct is called\n";
		}
		public function __destruct(){
			echo "the method:__destruct is called\n";
		}
		public function __toString(){
			return "the method:__toString is called\n";
		}
		public function __wakeup(){
			echo "the method:__wakeup is called\n";
		}
		public function __sleep(){
			echo "the method:__sleep is called\n";
			return array('name','age');
		}
	}
	$dog = new animal();//对类进行实例化时，自动调用__construct()
	$serializedDog = serialize($dog);//对dog对象进行序列化时，自动调用__sleep()
	echo $serializedDog . "\n";//echo 序列化的dog对象
	
	$newDog = unserialize($serializedDog);//反序列化已经被序列化的dog对象，自动调用__wakeup()
	var_dump($newDog);//输出反序列化的结果
	$newDog->eat();//dog对象调用eat()方法
				   //程序结束，调用__destruct()
	?>

```



* **serialize（）**，参数为一个对象，返回对象的字节流表示

  * 序列化后字符串格式：O:6:"animal":1:{s:4:"name";s:7:"dahuang";}
    对象类型:长度:"名字":类中变量的个数:{类型:长度:"名字";类型:长度:"值";......}

  * 不同修饰符的参数长度不同：

    * 当name受到public修饰时：public $name = ‘dahuang’;
      ![image-20230917141416629](.\images\image-20230917141416629.png)

    * 当name受到private修饰时：private $name = ‘dahuang’;

      ![image-20230917141724074](.\images\image-20230917141724074.png)

    * 当name受到protected修饰时：protected $name = ‘dahuang’;

      ![image-20230917141813434](.\images\image-20230917141813434.png)

* **unserialize（）**，参数为字符串，返回对象

#### PHP反序列化漏洞/PHP对象注入

> 我们已经认识到了PHP的序列化与反序列化过程，但是如何利用这些漏洞呢？这取决与应用程序、可用的类和magic方法，序列化对象包含攻击者控制的对象值。
>
> 这里介绍一个重要的概念，POP链。POP 面向属性编程(Property-Oriented Programing) 常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链,最终达到攻击者邪恶的目的。

##### pop链构造案例

```php
<?php
//flag is in flag.php
error_reporting(0);
class Read {
    public $var;
    public function file_get($value)
    {
        $text = base64_encode(file_get_contents($value));
        return $text;
    }
    public function __invoke(){
        $content = $this->file_get($this->var);
        echo $content;
    }
}

class Show
{
    public $source;
    public $str;
    public function __construct($file='index.php')
    {
        $this->source = $file;
        echo $this->source.'Welcome'."<br>";
    }
    public function __toString()
    {
        return $this->str['str']->source;
    }

    public function _show()
    {
        if(preg_match('/gopher|http|ftp|https|dict|\.\.|flag|file/i',$this->source)) 		 {
            die('hacker');
        } else {
            highlight_file($this->source); 
        }
    }

    public function __wakeup()
    {
        if(preg_match("/gopher|http|file|ftp|https|dict|\.\./i", $this->source)) {
            echo "hacker";
            $this->source = "index.php";
        }
    }
}

class Test
{
    public $p;
    public function __construct()
    {
        $this->p = array();
    }

    public function __get($key)
    {
        $function = $this->p;
        return $function();
    }
}

if(isset($_GET['hello']))
{
    unserialize($_GET['hello']);
}
else
{
    $show = new Show('pop3.php');
    $show->_show();
}
```

  这个案例来自于一个ctf题目，构造链条十分清晰：

1. unserialize($_GET['hello'])，反序列化参数可控，这里反序列化后并没有其他行为，所以\_\_wakeup是唯一能作为pop链起点的方法
2. 通读代码，发现只有Show类的\_\_wakeup被手动定义且有preg_match("/gopher|http|file|ftp|https|dict|\.\./i", $this->source)，这里如果$this->source为对象，就可触发\_\_tostring方法。
3. \_\_toString也在Show中手动定义，再看下\_\_tostring魔术方法中，首先找到str这个数组，取出key值为str的value的属性source，那么如果这个value值不存在的话就会触发\_\_get魔术方法。再次通读全篇，看到Test类中存在\_\_get魔术方法。
4. Test类种的\_\_get方法获取了属性p，并将其当作函数调用，这里就会触发\_\_invoke方法，而Read类中定义了\_\_invoke方法
5. Read类中定义的\_\_invoke方法调用了file_get这个函数，可以读取文件

POP链：

**unserialize函数（变量可控）–>__wakeup()魔术方法–>__tostring()魔术方法–>__get魔术方法–>__invoke魔术方法–>触发Read类中的file_get方法–>触发file_get_contents函数读取敏感文件**

总结： 反序列化漏洞的核心是，在unserialize的参数可控的情况下，我们可以给目标对象的属性赋任意对象和值，这就意味着我们可以构造任意对象。而对象有许多魔术方法是无需显式调用的，我们需要找寻一个起点，例如__wakeup 、\_\_toString、\_\_destruct等方法，我们对这个起点方法的要求是，它会被自动调用，而且这个方法内部会有机会调用其他魔术方法，被调用的魔术方法同理，这样就可以形成调用的链条，最终也要寻找到一个出口的魔术方法，这个魔术方法进行了一些敏感操作。

##### Session反序列化

##### phar://协议
