### 序列化与反序列化

#### 常见magic方法

| 方法名         | 触发点                                                       |
| -------------- | ------------------------------------------------------------ |
| __construct    | 在创建对象时候初始化对象，一般用于对变量赋初值               |
| __destruct     | 和构造函数相反，在对象不再被使用时(将所有该对象的引用设为null)或者程序退出时自动调用 |
| __toString     | 当一个对象被当作一个字符串被调用，把类当作字符串使用时触发,返回值需要为字符串 |
| __wakeup()     | 使用unserialize时触发，反序列化恢复对象之前调用该方法        |
| __sleep()      | 使用serialize时触发 ，在对象被序列化前自动调用，该函数需要返回以类成员变量名作为元素的数组(该数组里的元素会影响类成员变量是否被序列化。只有出现在该数组元素里的类成员变量才会被序列化) |
| __destruct()   | 对象被销毁时触发                                             |
| __call()       | 在对象上下文中调用不可访问的方法时触发，即当调用对象中不存在的方法会自动调用该方法 |
| __callStatic() | 在静态上下文中调用不可访问的方法时触发                       |
| __callStatic() | 在静态上下文中调用不可访问的方法时触发                       |
| __get()        | 用于从不可访问的属性读取数据，即在调用私有属性的时候会自动执行 |
| __set()        | 用于将数据写入不可访问的属性                                 |
| __isset()      | 在不可访问的属性上调用isset()或empty()触发                   |
| __unset()      | 在不可访问的属性上使用unset()时触发                          |
| __invoke()     | 当脚本尝试将对象调用为函数时触发                             |

#### 对象序列化和反序列化

```php
	<?php
	class animal {
		public $name = 'dahuang';//define a virable
		public $age = '20';
		public function eat(){//define a simpe method
			echo $this->name . " is eatting...\n";
		}
		public function __construct(){
			echo "the method:__construct is called\n";
		}
		public function __destruct(){
			echo "the method:__destruct is called\n";
		}
		public function __toString(){
			return "the method:__toString is called\n";
		}
		public function __wakeup(){
			echo "the method:__wakeup is called\n";
		}
		public function __sleep(){
			echo "the method:__sleep is called\n";
			return array('name','age');
		}
	}
	$dog = new animal();//对类进行实例化时，自动调用__construct()
	echo serialize($dog)."\n";
	$serializedDog = serialize($dog);//对dog对象进行序列化时，自动调用__sleep()
	echo $serializedDog . "\n";//echo 序列化的dog对象
	$dog->eat();//dog对象调用eat()方法
				//程序结束，调用__destruct()
	?>

```

![在这里插入图片描述](.\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk1MDc4MQ==,size_16,color_FFFFFF,t_70)

PHP的几个魔法函数，在进行序列化的过程中的调用：

1、当不进行序列化时: 在进行类的实例化时，自动调用__construct();在输出对象时，自动调用

\_\_toString()；在程序结束时，自动调用\_\_destruct();\_\_sleep()与\_\_wakeup()均与序列化与反序列化

有关，在此过程不被调用。

2、当进行序列化时: 在进行类的实例化时，自动调用\_\_construct();在对创建的dog对象进行序列化

时，自动调用\_\_sleep()；echo $serializedDog，输出序列化的dog对象，在此不再调用

\_toString()；dog兑现调用eat()方法，然后程序结束，调用\_\_destruct().

3、在整个过程中，\_\_construct()总是在程序的开始调用，\_\_destruct()总是在程序的结束调用，这很

简单，因为，对所有的变量的初始化总是在程序的开始，释放变量总是在程序结束。

```php
	<?php
	class animal {
		public $name = 'dahuang';//define a virable
		public $age = '20';
		public function eat(){//define a simpe method
			echo $this->name . " is eatting...\n";
		}
		public function __construct(){
			echo "the method:__construct is called\n";
		}
		public function __destruct(){
			echo "the method:__destruct is called\n";
		}
		public function __toString(){
			return "the method:__toString is called\n";
		}
		public function __wakeup(){
			echo "the method:__wakeup is called\n";
		}
		public function __sleep(){
			echo "the method:__sleep is called\n";
			return array('name','age');
		}
	}
	$dog = new animal();//对类进行实例化时，自动调用__construct()
	$serializedDog = serialize($dog);//对dog对象进行序列化时，自动调用__sleep()
	echo $serializedDog . "\n";//echo 序列化的dog对象
	
	$newDog = unserialize($serializedDog);//反序列化已经被序列化的dog对象，自动调用__wakeup()
	var_dump($newDog);//输出反序列化的结果
	$newDog->eat();//dog对象调用eat()方法
				   //程序结束，调用__destruct()
	?>

```



* **serialize（）**，参数为一个对象，返回对象的字节流表示

  * 序列化后字符串格式：O:6:"animal":1:{s:4:"name";s:7:"dahuang";}
    对象类型:长度:"名字":类中变量的个数:{类型:长度:"名字";类型:长度:"值";......}

  * 不同修饰符的参数长度不同：

    * 当name受到public修饰时：public $name = ‘dahuang’;
      ![image-20230917141416629](.\images\image-20230917141416629.png)

    * 当name受到private修饰时：private $name = ‘dahuang’;

      ![image-20230917141724074](.\images\image-20230917141724074.png)

    * 当name受到protected修饰时：protected $name = ‘dahuang’;

      ![image-20230917141813434](.\images\image-20230917141813434.png)

* **unserialize（）**，参数为字符串，返回对象

#### PHP反序列化漏洞/PHP对象注入

我们已经认识到了PHP的序列化与反序列化过程，但是如何利用这些漏洞呢？这取决与应用程序、可

用的类和magic方法，序列化对象包含攻击者控制的对象值。在利用反序列化漏洞时，第一步就

是在web应用程序寻找定义的\_\_wakeup()和\_\_sleep()方法，通过上面的讲述可以知道这两个magic方

法只有在进行序列化和反序列化时才会被调用，通过触发这些方法，利用反序列化漏洞。
