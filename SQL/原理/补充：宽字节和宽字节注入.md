### 宽字节和宽字节注入

#### 编码相关

##### 编码规范：ASCII编码、unicode编码

讨论宽字节之前，我们先讨论一下编码相关的问题

> 我们都知道在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以**组合出最多256种状态**，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。
>
> 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。ASCII码一共规定了128个字符的编码，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。

ASCII码能表示的128个符号太少了，对于英语字符还够用，但是对于汉语和一些其他字符数量很多的语言，ASCII码就完全无法表示，于是为了解决这个问题，不同国家和地区开始使用不同的编码方式解决这个问题。例如，

> 一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256x256=65536个符号。

世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。

可以想象，如果有一种编码，**将世界上所有的符号都纳入其中**。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是**Unicode**，就像它的名字都表示的，这是一种所有符号的编码。

> Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字“严”。具体的符号对应表，可以查询[unicode.org](http://www.unicode.org/)，或者专门的[汉字对应表](http://www.chi2ko.com/tool/CJK.htm)。

但有一点需要注意，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。我们在将unicode中每个符号对应的二进制代码存入计算机时，需要考虑两个问题：

> 1.我们该以多少个字节存储unicode编码，有两种解决方案：一，编码多长我们就用多少个字节，例如‘0’的编码为0x4f，我们就用一个字节，“你”这个汉字的编码为0x4F60，我们就用两个字节；二，固定长度，全部用定长个字节表示。
>
> 2.1的方案一貌似更好，因为明显这样可以节省更多存储空间，但实际这个方案存在问题，所以才会有方案二的出现，问题就是计算机怎么判定我该将几个字节识别成字符，就比如遇到0x4f60，计算机该识别为"0\`"两个单字节字符还是识别为一个双字节字符 ‘你’ 呢？

##### 具体实现：变长utf8、定长gb系列

上一节谈到了，我们不能机械的将二进制代码直接存入计算机，因为我们面临两个亟待解决的问题，所以为了解决这两个问题，我们需要一些具体的方法来将unicode编码存入计算机，这些方法就是本节的标题。我们先来谈谈utf系列，以utf8为例看看变长编码

> UTF-8: 是一种变长字符编码，被定义为将码点编码为 1 至 4 个字节，具体取决于码点数值中有效二进制位的数量:
>
> UTF-8 的编码规则:
>
> 1. 对于单字节的符号，字节的第一位设为 **0**，后面 7 位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的, 所以 UTF-8 能兼容 ASCII 编码，这也是互联网普遍采用 UTF-8 的原因之一
> 2. 对于 **n** 字节的符号（ **n > 1**），第一个字节的前 **n** 位都设为 **1**，第 **n + 1** 位设为 **0**，后面字节的前两位一律设为 **10** 。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码
>
> 我们来看看具体的例子，一个'你'的unicode编码0x4f60（0b01001111 01100000）如何与存入计算机的 0xe4bda0(0b **1110**0100 **10**111101 **10**100000)对应起来，加粗部分那就是utf8编码规则中设置的位
>
> ![image-20230909131340017](.\images\image-20230909131340017.png)

GB系列有很多种，包括GB2312、GBK、GB18030，为了兼容更多字符，这三种编码从前往后发展产生，我们来谈谈GBK

> GBK并不是根据unicode编码来实现的，由于有些汉字是在 GB2312 标准发布之后才简化的，还有一些人名、繁体字、日语和朝鲜语中的汉字也没有包括在内，所以，在 GB2312 的基础上添加了这部分字符，就形成了 GBK ，全称 《汉字内码扩展规范》，共收录了两万多个汉字和字符，它完全兼容 GB2312，当然也兼容ASCII。
>
> GBK与utf系列最不一样的是，它是定长的，其编码范围：8140－FEFE/。

这里需要注意，网上很多的utf8在线转换工具的转换结果都不正确，他们将utf8与unicode混淆了。

![image-20230909141348070]( .\images\image-20230909141348070.png)

##### 不同编码方式的转换

> 这里主要说清楚一个问题，不同编码方式间是如何实现转换的，utf8将‘你’以0xe4bda0存入计算机，而gbk则将0xc4e3存入计算机，当我们需要将utf8转为gbk编码时，计算机以utf8读到0xe4bda0，识别出这是‘你’这个字符，然后再以gbk编码方式将0xc4e3存入计算机，这就完成了转换。

#### 宽字节注入

##### 数据库编码

```sql
# 查看数据库编码
show variables like "%char%set%";

# 设置数据库编码
set 变量名=编码方式;
```

![image-20230909140754738](.\images\image-20230909140754738.png)

* character_set_client：是客户端的编码方式，包括mysql客户端命令行界面、各种编程语言的数据库接口。
* _connection：
* _database：
* _result

上面的图片中，client和database的编码方式不同，我们可以看看差别：

![image-20230909142556370](.\images\image-20230909142556370.png)

![image-20230909142653630](.\images\image-20230909142653630.png)

> mysql客户端向服务器端发送数据时，实际上是发送的字节流，而character_set_client的功能就是告诉服务器端客户端使用的什么编码，好让服务器端选择合适的方式解码，所以设置character_set_client其实并不能改变客户端的编码。
>
> 关于后面的三个变量的作用，我也查找了很久，但是都是一些似是而非的回答，我感觉没有找到我想要的答案，而且他们对宽字节注入的发生影响不大，这里就暂时略过了。

##### 宽字节注入的发生

我们以经典的sqllab宽字节注入的题目less32为例：

![image-20230910193430447](.\images\image-20230910193430447.png)

> 这一题使用了addslashes过滤了我们的输入，我们的pyload是1%df' union select 1,user(),3 -- ，addslashes为输入的 ‘ 加上了转义符\ ，我们输入的payload中的%df则会将转义符“吃掉”，从而实现宽字节注入。
>
> 这里PHP的默认编码方式是utf8，%df既0xdf （0b**110**11111），utf8无法解析这个字符，因为0b**110**表示这是一个二字节字符，所以这里会尝试将0xdf5c(0b**110**11111 01011100，5c是\\)视为一个整体，但是这里0x5c不是以**10**开头的，不符合utf8二字节字符的规范，所以我们看到的是一个乱码和\\，utf8以字节形式保存这个无法表示字符时，也是保存为0xdf。当编程语言和character_set_client相同时，这无伤大雅，我们以utf8编码发送给服务端，服务端以utf8形式解码，无非是有乱码字符，可是当\_client不同发生编码转换时，就产生了问题。由前面编码转换的过程可知，转换过程中需要找到二进制代码在utf8对应的字符，而0xdf没有对应的字符，于是只能不变动地复制到新的编码方式中，在gbk中，0xdf5c则是一个合法字符 ’運‘，我们本来以utf8的编码方式发送的select username,password rom users where id='**1%df**\\**'or 1=1 limit 0,1 -- **‘，服务端看到了\_client=GBK，于是将客户端发送的内容按GBK解码，所以服务端解码后变为select username,password rom users where id='**1運**'or 1=1 limit 0,1 -- **‘。
>
> 让我们具体看看代码
>
> ![image-20230909200826859](.\images\image-20230909200826859.png)
>
> 这里mysqli_query($con1,"SET NAMES GBK")的确将\_client设为了GBK，我们可以做一个验证，将这里GBK改为UTF8或者直接set  character_set_client=utf8，发现宽字节注入消失了。

##### 防御宽字节注入

防御宽字节注入，就是要确保编程语言与mysql服务端收到的\_client编码统一，以PHP为例，我们可以：

* 数据库设置时，设置编码，保证客户端编码与数据库编码统一
* 在每一次数据库连接后，马上query($con，'set names 与php相同的编码'\)
* 使用mysql_set_charset()指定字符集，然后使用mysql_real_escape_string进行转义，mysql_real_escape_string会根据mysql_set_charset()设置的字符集考虑转义

