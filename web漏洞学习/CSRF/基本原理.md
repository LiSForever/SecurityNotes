### 基本原理

#### 概念简述

> **场景需求：**
> 小黑想要修改大白在购物网站tianxiewww.xx.com上填写的会员地址。
>                         **先看下大白是如何修改自己的密码的：**
> 登录---修改会员信息，提交请求---修改成功。
>                         所以小黑想要修改大白的信息，他需要拥有：1，登录权限 2，修改个人信息的请求。
>                     
>
> ​                        但是大白又不会把自己xxx网站的账号密码告诉小黑，那小黑怎么办？
> ​                        于是他自己跑到www.xx.com上注册了一个自己的账号，然后修改了一下自己的个人信息（比如：E-mail地址），他发现修改的请求是：
> ​                        【http://www.xxx.com/edit.php?email=xiaohei@88.com&Change=Change】
> ​                        于是，他实施了这样一个操作：把这个链接伪装一下，在小白登录xxx网站后，欺骗他进行点击，小白点击这个链接后，个人信息就被修改了,小黑就完成了攻击目的。
> ​                    
>
> ​                        **为啥小黑的操作能够实现呢。有如下几个关键点：**
> ​                        1.www.xxx.com这个网站在用户修改个人的信息时没有过多的校验，导致这个请求容易被伪造;
> ​                        ---因此，我们判断一个网站是否存在CSRF漏洞，其实就是判断其对关键信息（比如密码等敏感信息）的操作(增删改)是否容易被伪造。
> ​                        2.小白点击了小黑发给的链接，并且这个时候小白刚好登录在购物网上;
> ​                        ---如果小白安全意识高，不点击不明链接，则攻击不会成功，又或者即使小白点击了链接，但小白此时并没有登录购物网站，也不会成功。
> ​                        ---因此，要成功实施一次CSRF攻击，需要“天时，地利，人和”的条件。
> ​                        当然，如果小黑事先在xxx网的首页如果发现了一个XSS漏洞，则小黑可能会这样做：                        欺骗小白访问埋伏了XSS脚本（盗取cookie的脚本）的页面，小白中招，小黑拿到小白的cookie，然后小黑顺利登录到小白的后台，小黑自己修改小白的相关信息。
> ​                        ---所以跟上面比一下，就可以看出CSRF与XSS的区别：CSRF是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而XSS是直接盗取到了用户的权限，然后实施破坏。                    
>
> ​                        因此，网站如果要防止CSRF攻击，则需要对敏感信息的操作实施对应的安全措施，防止这些操作出现被伪造的情况，从而导致CSRF。比如：
> ​                        --对敏感信息的操作增加安全的token；
> ​                        --对敏感信息的操作增加安全的验证码；
> ​                        --对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。

#### 攻击

##### GET型

![image-20230827163242653](.\images\image-20230827163242653.png)

* 可以直接构造目标网址，但是不具有隐蔽性

* 较为隐蔽构造，不将目标网址直接放在url中

  * 构造包含目标网址的html页面放在黑客的服务器上

  <img src=".\images\image-20230827163017900.png" alt="image-20230827163017900"  />

​			这个页面可以通过img标签或者其他操作，向目标发起请求，但是被攻击者却难以察觉

​			被害人访问该网页

​			![image-20230827163559406](.\images\image-20230827163559406.png)

​			看看我们实际上的请求

![image-20230827163815389](.\images\image-20230827163815389.png)

![image-20230827163833273](.\images\image-20230827163833273.png)

​		携带着认证字段cookie

​		![image-20230827163920875](.\images\image-20230827163920875.png)

​		被成功篡改性别

##### POST型

> POST型的利用方式其实和上面的GET型的隐蔽型利用大差不差

#### 防御

##### 客户端防御

* 不要点击陌生链接
* 点击陌生链接时，使用浏览器的隐私窗口

##### 服务器端防御

* 存在缺陷的防御方式

  * 遵循标准的GET动作：标准的GET方法只能请求资源，而不能对服务器进行操作，当用户点击链接时，默认的请求方式都是GET，即使我们在自己的服务器构造表单也是POST，当我们限制了对服务器资源的删除和替代是标准的PUT和DELETE时，可以很大程度上防止CSRF攻击

  * 检查HTTP Referer字段：在一定程度上限制了CRSF，但是不能防御站内的csrf

* 对服务器存在负担的方式

  * 增加token：
  * 将一部分认证数据不要放在cookie中，且这部分数据攻击者无法伪造：

* 牺牲体验为代价：

  * 关键操作处添加验证码操作

  * 设置Samesite Cookie：Samesite是cookie的一个属性

    * 如果Samesite Cookie被设置为`Strict`，浏览器在任何跨域请求中都不会携带Cookie，新标签重新打开也不携带，所以说CSRF攻击基本没有机会；但是跳转子域名或者是新标签重新打开刚登陆的网站，之前的Cookie都不会存在。尤其是有登录的网站，那么我们新打开一个标签进入，或者跳转到子域名的网站，都需要重新登录。对于用户来讲，可能体验不会很好。
    * 如果Samesite Cookie被设置为`Lax`，那么其他网站通过页面跳转过来的时候可以使用Cookie，可以保障外域连接打开页面时用户的登录状态。但相应的，其安全性也比较低。

    ![image-20230827180652167](D:\安全\文档\webSecurityNotes\web漏洞学习\JSONP和JSON劫持\images\image-20230827180652167.png)

总结：

> WEB的身份验证机制可以保证一个请求是来自于哪个用户的浏览器，但是却不能保证请求是否由本人发起的，所以修复和防御也是保证请求由用户本人发起即可。所以修复方法无非就两大类，一是建立会话，客户端与服务器端的每次通信都建立了会话，当用户点击陌生链接时，没有和服务器端建立起会话，请求失败；二，确保让用户知道自己进行了什么操作，用户不知道的情况下操作一定失败

#### 对于防御机制的绕过

* 对于referer和origin：

  * <meta name="referrer" content="never"><!-- 可以使两项为空，当目标站点校验不严格时 -->

  * 直接从浏览器外部进入也使两项为空，当目标站点校验不严格时，空值可绕过
  * 可以在目标站内构造恶意请求，使两项合法
  * TODO：data、file等伪协议
  * 部分站点的对于referer和origin的验证做的不到位，可能合法站点是b.com ,构造自己的站点为a.b.com.com

#### 深入讨论

##### 如何设置可以通过表单设置PUT和DELETE请求吗

##### 可以设置http首部的同时保留cookie吗

##### bilibili的例子