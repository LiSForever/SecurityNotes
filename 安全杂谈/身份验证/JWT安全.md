### JWT简介

#### 概述

> Json web token (简称JWT)，是目前最流行的跨域认证解决方案，是一种认证授权机制。
> 
> JWT 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。

#### JWT的由来

* session的产生
  
  * HTTP协议本身是无连接、无状态的。而这对于单纯的浏览型网页是十分友好的，它不需要记住是谁发送的请求，每一个请求对于它来说都是全新的，服务器也不需要额外的资源去记忆没有个用户
  
  * 最初的解决办法是那就是给大家都发一个会话标识(session id)，这个会话标识是一串很长的随机字符串，每个人都不一样， 然后每次大家发起HTTP请求的时候，把这个字符串给发送给服务器， 这样服务器就能区分开谁是谁了。
  
  * 不过这种方法虽然解决了基本的认证问题，但是却给服务器带来了巨大的负担。每个人只需要保存自己的session id，而服务器要保存所有人的session id， 如果访问服务器的用户多了， 甚至需要保存成千上万，甚至几十万个用户的数据，这对服务器说是一个巨大的开销 ，而且 严重的限制了服务器扩展能力。而且在如今分布式系统流行的情况下，还采用session会由一个问题，分布式系统不同的节点之间要频繁同步session。

* 为了解决session的一些问题，产生了JWT：
  
  * 设想一种方式，只让每个客户端去保存它们的身份，为了了确认每一个用户的身份，并防止他们伪造。可以将用户的身份信息用签名来保证它的不可篡改性，然后让用户自己保存数据。
  * 顺着这个思路，有人就想让用户保存更多的信息，这样服务器的负担就更小了。有人提出将用户的一些其它数据和user id一起发送给用户，让用户自己保存，然后利用密钥保证安全性，这就是JWT。JWT将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。JWT的出现进一步释放了服务器的性能。

### JWT的组成

[JSON Web Tokens - jwt.io](https://jwt.io/)可对jwt进行解析分析

```txt
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.Sigature
```

以 . 分割为三个部分，前两个不分均经过base64

#### header

Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子

```json
{
    "alg":"HS256",
    "typ":"JWT"
}
```

其中 typ 不变，永远都是 JWT ， alg 字段会根据所使用的签名算法不同而改 变，有时还会有 jwk 字段（这个也成为了一个安全问题）

#### payload

payload 中包含三部分内容：标准中注册的声明、公共的声明和私有的声明。

* 标准中注册的声明： 
  * iss : jwt签发者 
  * sub : jwt所面向的用户 
  * aud : 接收jwt的一方 
  * exp : jwt的过期时间，这个过期时间必须要大于签发时间 
  * nbf : 定义在什么时间之前，该jwt都是不可用的. 
  * iat : jwt的签发时间 
  * jti : jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 
* 公共的声明 ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息. 但不建议添加敏感信息，因为该部分在客户端可解密. 
* 私有的声明 ： 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64 是对称解密的，意味着该部分信息可以归类为明文信息。

#### Signature

这里签名采用的算法在第一部分中有声明，通常是HMAC SHA256，这是一个对称加密算法

```txt
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

secret由服务端保存，一旦泄露，使用该secret可任意伪造jwt。

### JWT的安全问题

#### 敏感信息泄露

  前面提到过，为了减轻服务器的压力，可以将一些服务器需要的信息存放进jwt中交由jwt保存，但是jwt包含信息的字段header和payload是不加密的，如果开发者将一些敏感信息也交由jwt保存，就会造成敏感信息泄露的问题。

#### 签名未校验

* (CVE-2020-28042) Null signature vulnerability

* 在fusionauth-jwt 1.3.0以前，该组件即使删除了 JWT 地签名部分仍然可以通过验证。

* 造成伪造任意用户登录

#### none签名方法

* (CVE-2015-2951) The alg=none signature-bypass vulnerability

* header中的"alg"指定的是加密算法，如果允许设置为none，实际上就等同于签名未校验

#### 不当的错误处理

* CVE-2019-7644

* 如果你发送的签名是错的，那么服务器会通知你签名错误，并返回一个正确的签名

#### JWT头部注入

* header
  * kid 用于标识密钥的唯一**标识符**
  * typ 表示 JWT 的类型，通常为 "JWT"
  * alg 指定用于签名和验证 JWT 的算法
  * jwk 包含了公钥或私钥的信息，以 JSON 格式表示
    * kty 表示密钥的类型
  * jku jku的内容是一个链接，指向一个jwk

##### 错误配置导致可接受注入jwk的公钥

* jwt采用RSA算法作为签名时，正常情况下公钥和私钥都由服务端保存，无需客户端在jwt中嵌入公钥或使用私钥进行签名
* 在某些错误配置的情况下，服务端会使用jwt中jwk字段中保存的公钥进行签名
* 此时，攻击者可以自己生成一对秘钥，在构造好想要的header和payload（将jwk嵌入）后，利用私钥签名，服务端使用嵌入的公钥成功验证签名，伪造成功

##### 错误配置导致可接受注入jku的公钥

* 在服务端配置不当时，可以接受jku指向不可信的链接，或者jku指向的链接攻击者可控
* 攻击方式同上

##### 错误配置导致可接受Kid注入

* 服务器可能使用几个密钥来签署不同种类的数据，因此JWT的报头可能包含kid(密钥id)参数，这有助于服务器在验证签名时确定使用哪个密钥，验证密钥通常存储为一个JWK集，服务器端根据Kid来确定选择哪一个JWK。但JWS规范没有为这个Kid的值做具体的定义，因此可能会发生一种情况，kid被设置为存放JWK的文件路径，或者指向一个数据库表，如果这种情况下，后端没有对Kid值进行校验，则攻击者可以通关操纵Kid的值来选择签名的秘钥
* 简单的做法是，当Kid被设置为文件路径时，选择../../../../../dev/null这个空文件为验证签名的秘钥

#### jwt库和后端实现缺陷造成的算法混淆攻击

```php
function verify(token, secretOrPublicKey){
    algorithm = token.getAlgHeader();
    if(algorithm == "RS256"){
        // Use the provided key as an RSA public key
    } else if (algorithm == "HS256"){
        // Use the provided key as an HMAC secret key
    }
}

publicKey = <public-key-of-server>;
token = request.getCookie("session");
verify(token, publicKey);
```

* 非对称加密算法使用公钥进行签名，对称加密算法使用唯一秘钥进行签名
* 当后端实现存在缺陷时，验证对称加密算法时使用了非对称加密算法的公钥，即非对称加密的公钥被作为对称加密的唯一秘钥
* 当公钥泄漏时且知道对称加密的算法时，使用其作为对称加密的秘钥进行签名，即可伪造jwt
* 若公钥没有泄露，也可尝试https://github.com/silentsignal/rsa_sign2n该工具可以根据两个jwt推测出公钥

#### 其它安全问题

##### jwt无限期使用

##### jwt刷新缺陷

* 旧jwt可无限获取新jwt